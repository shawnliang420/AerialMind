import os
import numpy as np
import pandas as pd

# ==============================================================================
# --- 1. Global Configuration ---
# ==============================================================================

# Root directory containing all attribute folders (Day, Night, etc.)
PROCESSED_DATA_ROOT = './processed_attribute_results'

# Evaluation result filename generated by TrackEval
SUMMARY_FILENAME = 'pedestrian_summary.txt'

# Output filename for the final report
FINAL_REPORT_FILE = './processed_attribute_results/attribute_final_report.txt'

# --- Composite Metrics Attribute Set Definitions ---
# HOTA_S (Scene Robustness) includes the following attributes
SCENE_ATTRIBUTES = {'Night', 'Occlusion', 'Low_Resolution'}

# HOTA_M (Motion Adaptability) includes the following attributes
MOTION_ATTRIBUTES = {'ViewPoint_Change', 'Scale_Variation', 'Fast_Motion', 'Rotation'}


# ==============================================================================
# --- 2. Core Functions ---
# ==============================================================================

def parse_hota_from_summary(file_path: str) -> float:
    """
    Parse HOTA score from pedestrian_summary.txt file.
    Returns HOTA score value, or None if file not found or format error.
    """
    if not os.path.isfile(file_path):
        print(f"  - Warning: Summary file not found: {file_path}")
        return None
    try:
        # Use pandas to read whitespace-separated file for robustness
        df = pd.read_csv(file_path, delim_whitespace=True)
        if 'HOTA' in df.columns:
            # HOTA value is in the first data row
            hota_score = df['HOTA'].iloc[0]
            return float(hota_score)
        else:
            print(f"  - Error: 'HOTA' column not found in file {file_path}.")
            return None
    except Exception as e:
        print(f"  - Error: Failed to parse file {file_path}: {e}")
        return None

def calculate_geometric_mean(scores: list) -> float:
    """
    Calculate geometric mean of a list of scores.
    Formula: HOTA_A = (Î  HOTA_Ai)^(1/N)
    """
    if not scores:
        return 0.0
    
    scores_array = np.array(scores, dtype=float)
    
    # Geometric mean requires all positive numbers. If zero or negative exists, result is 0.
    if np.any(scores_array <= 0):
        print("  - Warning: List contains zero or negative values for geometric mean calculation, result will be 0.")
        return 0.0
        
    # Use logarithm to avoid precision issues from small products
    # log( (a*b*c)^(1/3) ) = (log(a)+log(b)+log(c))/3
    log_sum = np.sum(np.log(scores_array))
    geometric_mean = np.exp(log_sum / len(scores_array))
    
    return float(geometric_mean)


# ==============================================================================
# --- 3. Main Program ---
# ==============================================================================

def main():
    """
    Main execution function
    """
    print("=" * 70)
    print("--- Starting to aggregate evaluation results and calculate composite metrics ---")
    print("=" * 70)

    attribute_hota_scores = {}

    # Iterate through all attribute folders
    if not os.path.isdir(PROCESSED_DATA_ROOT):
        print(f"Error: Root directory '{PROCESSED_DATA_ROOT}' does not exist. Please run evaluation first.")
        return

    for attr_name in sorted(os.listdir(PROCESSED_DATA_ROOT)):
        # TrackEval output path is {TRACKERS_FOLDER}/{TRACKERS_TO_EVAL}/...
        # In this case it is {attr_dir_path}/{attr_dir_path}/...
        summary_path = os.path.join(PROCESSED_DATA_ROOT, attr_name,  SUMMARY_FILENAME)
        
        print(f"Reading results for attribute '{attr_name}'...")
        hota_score = parse_hota_from_summary(summary_path)
        
        if hota_score is not None:
            attribute_hota_scores[attr_name] = hota_score
            print(f"  - Successfully retrieved HOTA = {hota_score:.4f}")

    # --- Calculate Composite Metrics ---
    print("\n--- Calculating composite metrics ---")
    
    # HOTA_S
    hota_s_values = [attribute_hota_scores[attr] for attr in SCENE_ATTRIBUTES if attr in attribute_hota_scores]
    if len(hota_s_values) != len(SCENE_ATTRIBUTES):
        print(f"Warning: Some attribute results for HOTA_S are missing. Expected {len(SCENE_ATTRIBUTES)}, found {len(hota_s_values)}.")
    hota_s_final = calculate_geometric_mean(hota_s_values)
    print(f"HOTA_S (Scene Robustness) calculated using scores: {hota_s_values}")
    
    # HOTA_M
    hota_m_values = [attribute_hota_scores[attr] for attr in MOTION_ATTRIBUTES if attr in attribute_hota_scores]
    if len(hota_m_values) != len(MOTION_ATTRIBUTES):
        print(f"Warning: Some attribute results for HOTA_M are missing. Expected {len(MOTION_ATTRIBUTES)}, found {len(hota_m_values)}.")
    hota_m_final = calculate_geometric_mean(hota_m_values)
    print(f"HOTA_M (Motion Adaptability) calculated using scores: {hota_m_values}")

    # --- Save Final Report ---
    print(f"\n--- Writing all results to '{FINAL_REPORT_FILE}' ---")
    
    try:
        with open(FINAL_REPORT_FILE, 'w') as f:
            f.write("========== Attribute Evaluation Final Report ==========\n\n")
            
            f.write("--- Individual Attribute HOTA Scores ---\n")
            for attr, score in sorted(attribute_hota_scores.items()):
                f.write(f"{attr:<20}: {score:.4f}\n")
            
            f.write("\n\n--- Composite Metrics ---\n")
            f.write(f"HOTA_S (Scene Robustness): {hota_s_final:.4f}\n")
            f.write(f"HOTA_M (Motion Adaptability): {hota_m_final:.4f}\n")
            
            f.write("\n\n--- Composite Metrics Description ---\n")
            f.write(f"HOTA_S is the geometric mean of HOTA scores for: {', '.join(sorted(list(SCENE_ATTRIBUTES)))}\n")
            f.write(f"HOTA_M is the geometric mean of HOTA scores for: {', '.join(sorted(list(MOTION_ATTRIBUTES)))}\n")
        
        print(f"\nReport saved successfully!")

    except Exception as e:
        print(f"\n!!! Error: Failed to write report: {e}")

if __name__ == '__main__':
    main()